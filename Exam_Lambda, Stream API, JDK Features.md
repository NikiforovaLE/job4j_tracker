# Экзамен. Lambda, Stream API, JDK Features.

## Оглавление

1. [Что такое lambda-выражение?](#1-Что-такое-lambda-выражение)
2. [Что такое функциональные интерфейсы?](#2-Что-такое-функциональные-интерфейсы)
3. [Перечислите функциональные интерфейсы из пакета java.util.function.](#3-Перечислите-функциональные-интерфейсы-из-пакета-javautilfunction)
4. [Что такое функции высшего порядка?](#4-Что-такое-функции-высшего-порядка)
5. [Какие функциональные интерфейсы из пакета java.util.function поддерживают функции высшего порядка?](#5-Какие-функциональные-интерфейсы-из-пакета-javautilfunction-поддерживают-функции-высшего-порядка)
6. [Что такое ссылки на методы?](#6-Что-такое-ссылки-на-методы)
7. [Что такое ссылки на конструкторы?](#-7-Что-такое-ссылки-на-конструкторы)
8. [Расскажите о зоне видимости переменных в lambda - выражениях?](#8-Расскажите-о-зоне-видимости-переменных-в-lambda-выражениях)
9. [Как быть в ситуации, если внутри lambda-выражения операторы могут выкинуть исключение?](#9-Как-быть-в-ситуации-если-внутри-lambda-выражения-операторы-могут-выкинуть-исключение)
10. [Что такое Stream API?](#10-Что-такое-Stream-API)
11. [Расскажите, какой шаблон проектирования используется внутри Stream API?](#11-Расскажите-какой-шаблон-проектирования-используется-внутри-Stream-API)
12. [Перечислите конвейерные методы Stream API.](#12-Перечислите-конвейерные-методы-Stream-API)
13. [Перечислите терминальные методы Stream API.](#13-Перечислите-терминальные-методы-Stream-API)
14. [Что такое ленивая загрузка?](#14-Что-такое-ленивая-загрузка)
15. [Что делает метод filter?](#15-Что-делает-метод-filter)
16. [Что делает метод map.](#16-Что-делает-метод-map)
17. [Что делает метод flatMap?](#17-Что-делает-метод-flatMap)
18. [Что делает метод collect?](#18-Что-делает-метод-collect)
19. [Что делает метод reduce?](#19Что-делает-метод-reduce)
20. [Что делает метод findFirst?](#20Что-делает-метод-findFirst)
21. [Возможно ли прервать выполнение потока по аналогии с break?](#21-Возможно-ли-прервать-выполнение-потока-по-аналогии-с-break)
22. [Возможно ли пропустить элемент потока по аналогии с continue?](#22-Возможно-ли-пропустить-элемент-потока-по-аналогии-с-continue)
23. [Что такое Optional?](#23-Что-такое-Optional)
24. [Перечислите методы Optional?](#24-Перечислите-методы-Optional)
25. [Расскажите про фабричные методы List.of, Set.of, Map.of?](#25-Расскажите-про-фабричные-методы-Listof-Setof-Mapof)
26. [Для чего используется ключевое слово var?](#26-Для-чего-используется-ключевое-слово-var)
27. [В каких случаях можно использовать var?](#27-В-каких-случаях-можно-использовать-var)

## 1 Что такое lambda-выражение?

**_Лямбда-выражение_** - анонимный (т.е безымянный) метод. Но этот метод не выполняется самостоятельно, а служит для
реализации метода, определяемого в функциональном интерфейсе. Таким образом, лямбда-выражение приводит к некоторой форме
анонимного класса. Нередко лямбда-выражения называют также _замыканиями_.

[К оглавлению &#8593;](#Оглавление)

## 2 Что такое функциональные интерфейсы?

**Функциональный интерфейс** - это интерфейс, который содержит только _один_
абстрактный метод, при этом статические и дефолтные методы могут присутствовать в любом количестве. Как правило, в таком
методе определяется предполагаемое назначение интерфейса. Следовательно, функциональный интерфейс представляет
единственное действие. Кроме того, в функциональном интерфейсе определяется целевой тип лямбда-выражения. В связи с этим
необходимо подчеркнуть следующее:
лямбда-выражение можно использовать только в том контексте, в котором определен его целевой тип. И еще одно замечание:
функциональный интерфейс иногда еще называют SАМ-типом, где сокращение SAM обозначает Single Abstract Method -
единственный абстрактный метод.

[К оглавлению &#8593;](#Оглавление)

## 3 Перечислите функциональные интерфейсы из пакета java.util.function.

Comparator, Comparable, Supplier, Consumer(BiConsumer), Function(BiFunction), Predicate (BiPredicate), UnaryOperator (
BinaryOperator)

+ Supplier

Supplier (поставщик) используется для создания какого-либо объекта. Он имеет метод
`get()`, который ничего не принимает на вход и возвращает объект. Основное применение этого интерфейса – создание новых
объектов.

```java

@FunctionalInterface
public interface Supplier<T> {

    /**
     * Gets a result.
     *
     * @return a result
     */
    T get();
}
```

Примеры:

```java
package ru.job4j.function;

import java.util.function.Supplier;

public class FunctionInterfaceUsage {
    public static void main(String[] args) {
        Supplier<String> stringSupplier = () -> "New String For Interface";
        System.out.println(stringSupplier.get());

        List<String> num = List.of("one", "two", "three", "one", "two", "three");
        Supplier<Set<String>> setSupplier = () -> new HashSet<>(num);
        Set<String> strings = setSupplier.get();
        for (String s : strings) {
            System.out.println(s);
        }
    }
}
```

В коде, представленном выше, мы объявили два интерфейса _Supplier_ с обобщенными типами _String_ и
_Set<String>_ соответственно. Записали их в переменные _stringSupplier_ и _setSupplier_.

+ Consumer и BiConsumer

Consumer (потребитель) используется в том случае, если нам нужно применить какое-то действие или операцию к параметру (
для BiConsumer к двум параметрам), при этом у метода нет возвращаемого значения. Объявляются эти интерфейсы следующим
образом:

```java

@FunctionalInterface
public interface Consumer<T> {

    /**
     * Performs this operation on the given argument.
     *
     * @param t the input argument
     */
    void accept(T t);
}

@FunctionalInterface
public interface BiConsumer<T, U> {

    /**
     * Performs this operation on the given arguments.
     *
     * @param t the first input argument
     * @param u the second input argument
     */
    void accept(T t, U u);
}
```

Два интерфейса отличаются только количеством параметров, которые принимает метод в этом интерфейсе.

Примеры:

```java
package ru.job4j.function;

import java.util.function.Supplier;

public class FunctionInterfaceUsage {
    public static void main(String[] args) {
        Supplier<String> stringSupplier = () -> "New String For Interface";
        Consumer<String> stringConsumer = System.out::println;
        stringConsumer.accept(stringSupplier.get());
        BiConsumer<String, String> twoStringsConsumer = (s, s1) -> System.out.println(s + s1);
        twoStringsConsumer.accept(stringSupplier.get(), " and Second String");

        List<String> num = List.of("one", "two", "three", "one", "two", "three");
        Supplier<Set<String>> setSupplier = () -> new HashSet<>(num);
        BiConsumer<Integer, String> biConsumer = (s, s1) -> System.out.println(s + s1);
        Set<String> strings = setSupplier.get();
        int i = 1;
        for (String s : strings) {
            biConsumer.accept(i++, " is " + s);
        }
    }
}

```

В данном примере показано применение интерфейса Consumer(BiConsumer) для вывода в консоль. При объявлении
функционального интерфейса BiConsumer мы указываем два типа обобщения и в лямбду, соответственно, передаем 2 параметра.

+ Predicate (BiPredicate)

Predicate (утверждение) наиболее часто применяется в фильтрах и сравнении и объявляются они следующим образом:

```java

@FunctionalInterface
public interface Predicate<T> {

    boolean test(T t);
}

@FunctionalInterface
public interface BiPredicate<T, U> {

    boolean test(T t, U u);
}

```

Т.е. в метод test() передается один или два параметра (в зависимости от функционального интерфейса), и метод возвращает
логическое значение true или false. Пример:

```java
package ru.job4j.function;

import java.util.function.Supplier;

public class FunctionInterfaceUsage {
    public static void main(String[] args) {
        //проверим не является ли передаваемая строка пустой
        Predicate<String> stringPredicate = String::isEmpty;
        System.out.println("Строка пустая: " + stringPredicate.test(""));
        System.out.println("Строка пустая: " + stringPredicate.test("test"));

        //проверим, содержится ли в строке передаваемое число
        BiPredicate<String, Integer> isContain = (s, i) -> s.contains(i.toString());
        System.out.println("Строка содержит подстроку: " + isContain.test("Name123", 123));
        System.out.println("Строка содержит подстроку: " + isContain.test("Name", 123));
    }
}
```

+ Function (BiFunction)

Function используется для преобразования входного параметра или двух параметров (для Bi-формы этого функционального
интерфейса) в какое-либо значение, тип возвращаемого значения может не совпадать с типом входных параметров. Объявляются
интерфейсы следующим образом:

```java

@FunctionalInterface
public interface Function<T, R> {

    R apply(T t);
}

@FunctionalInterface
public interface BiFunction<T, U, R> {

    R apply(T t, U u);
}
```

Пример:

```java
package ru.job4j.function;

import java.util.function.Supplier;

public class FunctionInterfaceUsage {
    public static void main(String[] args) {
        Function<String, Character> fromStringToChar = s -> s.charAt(2);
        System.out.println("Третий символ в строке: " + fromStringToChar.apply("first"));
        System.out.println("Третий символ в строке: " + fromStringToChar.apply("second"));

        BiFunction<String, Integer, String> biFuncForStringAndInt = (s, i) -> s.concat(" ").concat(i.toString());
        System.out.println("Результат работы бифункции: " + biFuncForStringAndInt.apply("Name", 123));
        System.out.println("Результат работы бифункции: " + biFuncForStringAndInt.apply("String number", 12345));
    }
}
```

+ UnaryOperator и BinaryOperator

UnaryOperator и BinaryOperator – это разновидность Function, в которых входные и выходные обобщенные параметры должны
совпадать. Объявляются интерфейсы следующим образом:

```java

@FunctionalInterface
public interface UnaryOperator<T> extends Function<T, T> {
}

@FunctionalInterface
public interface BinaryOperator<T> extends BiFunction<T, T, T> {
}
```

Эти два интерфейса расширяют Function и BiFunction соответственно. Иначе говоря, использование этих интерфейсов сводится
к применению Function и BiFunction в таких методах:

```java 
T apply(T t); 
T apply(T t1, T t2); 
```

Пример:

```java
package ru.job4j.function;

import java.util.function.Supplier;

public class FunctionInterfaceUsage {
    public static void main(String[] args) {
        UnaryOperator<StringBuilder> reverseOperator = StringBuilder::reverse;
        System.out.println("Строка после реверса: " + reverseOperator.apply(new StringBuilder("String for test")));
        System.out.println("Строка после реверса: " + reverseOperator.apply(new StringBuilder("tset rof gnirtS")));

        BinaryOperator<StringBuilder> appendOperator = (b1, b2) -> b1.append(" ").append(b2);
        System.out.println(
                "Строка после объединения: " + appendOperator.apply(
                        new StringBuilder("First string"),
                        new StringBuilder("Second string")
                )
        );
    }
}
```

В обобщении мы указываем только один тип, потому что для функциональных интерфейсов UnaryOperator и BinaryOperator
обобщенные типы должны совпадать, поэтому указывать три одинаковых типа обобщения не имеет смысла.

[К оглавлению &#8593;](#Оглавление)

## 4 Что такое функции высшего порядка?

Функции высшего порядка - это функции, зависящие от других функций. Для вычисления функции высшего порядка необходимо
сначала вычислить другую функцию. Функции высшего порядка описываются через композицию (Композиция - объект А не может
существовать без объекта B).

[К оглавлению &#8593;](#Оглавление)

## 5 Какие функциональные интерфейсы из пакета java.util.function поддерживают функции высшего порядка?

Comparator, Comparable

[К оглавлению &#8593;](#Оглавление)

## 6 Что такое ссылки на методы?

Начиная с JDK 8 в Java можно в качестве параметра в метод передавать ссылку на другой метод. Ссылка на метод - это
компактное лямбда-выражение, которое позволяет передавать ссылки на методы.

+ ссылка на метод передается в виде :

`имя_класса::имя_статического_метода `

+ для нестатических методов:

`объект_класса::имя_метода`

[К оглавлению &#8593;](#Оглавление)

## 7 Что такое ссылки на конструкторы?

Ссылка на конструктор - это компактное лямбда-выражение вида `название_класса::new `, которое позволяет передавать
ссылки на конструктор. При использовании конструкторов методы функциональных интерфейсов должны принимать тот же список
параметров, что и конструкторы класса, и должны возвращать объект данного класса.

Пример:

Есть класс Folder

```java
package ru.job4j.function;

import java.util.Objects;

public class Folder {
    private final String name;
    private final int size;

    public Folder(String name, int size) {
        this.name = name;
        this.size = size;
    }
}
```

Определим интерфейс, который будет использоваться для создания объектов типа Folder:

```java
package ru.job4j.function;

import java.util.function.Supplier;

public class FunctionInterfaceUsage {
    public static void main(String[] args) {
        BiFunction<String, Integer, Folder> construct = (s, i) -> new Folder(s, i);
        System.out.println(construct.apply("Exam", 500));
    }
}
```

[К оглавлению &#8593;](#Оглавление)

## 8 Расскажите о зоне видимости переменных в lambda - выражениях?

1. Переменная, объявленная внутри лямбда-выражения, доступна только в самом лямбда-выражении.
2. Переменная, объявленная вне лямбда-выражения, доступна как внутри лямбда-выражения, так и вне его. Переменную,
   объявленную вне лямбда-выражения, изменять внутри лямбда-выражения нельзя.

[К оглавлению &#8593;](#Оглавление)

## 9 Как быть в ситуации, если внутри lambda-выражения операторы могут выкинуть исключение?

В лямбда-выражениях нельзя использовать методы, которые могут выбросить исключения. Поток данных не может прерываться.
Поэтому следует **не использовать** лямбда-выражения с исключениями.

[К оглавлению &#8593;](#Оглавление)

## 10 Что такое Stream API?

В JDK 1.8 ввели интерфейс Stream. Этот интерфейс позволяет гибко работать с коллекциями.

Stream API - это новый способ работать со структурами данных в функциональном стиле. Чаще всего с помощью stream в Java
8 работают с коллекциями. Stream API - это поток данных.

[К оглавлению &#8593;](#Оглавление)

## 11 Расскажите, какой шаблон проектирования используется внутри Stream API?

Для построения потоков при работе со Stream используется шаблон проектирования Builder (в переводе на русский -
Строитель).

Строитель - это порождающий шаблон проектирования, который позволяет создавать сложные объекты пошагово. Строитель
позволяет использовать один и тот же код построения объекта для получения разных представлений объектов.

[К оглавлению &#8593;](#Оглавление)

## 12 Перечислите конвейерные методы Stream API.

Java Stream API предлагает два вида методов:

1. Конвейерные — возвращают другой stream, то есть работают как builder,
2. Терминальные — возвращают другой объект, такой как коллекция, примитивы, объекты, Optional и т.д.

Конвейерные методы:

+ filter - принимает объект Predicate<Task>, отфильтровывает записи, возвращает только записи, соответствующие условию
+ skip - позволяет пропустить N первых элементов
+ distinct - возвращает стрим без дубликатов (для метода equals)
+ map - преобразует каждый элемент стрима. Map ограничена, потому что каждый объект может быть отображен только одним
  объектом.
+ sorted - позволяет сортировать значения либо в натуральном порядке, либо задавая Comparator
+ mapToInt, mapToDouble, mapToLong - сработает как map, только вернет числовой stream (то есть стрим из числовых
  примитивов)
+ flatMap - преобразует каждый элемент потока в поток других объектов. Таким образом, каждый объект будет преобразован в
  ноль, один или несколько других объектов, поддерживаемых потоком. Содержание этих потоков будет затем помещают в
  возвращаемом потоке flatMap операции.
+ flatMapToInt, flatMapToDouble, flatMapToLong - сработает как map, но преобразует один элемент в ноль, один или
  множество других
+ limit - позволяет ограничить выборку определенным количеством первых элементов
+ peek - возвращает тот же стрим, но применяет функцию к каждому элементу стрима (выполнить действие над каждым
  элементом элементов, вернет стрим с исходными элементами)

  [К оглавлению &#8593;](#Оглавление)

## 13 Перечислите терминальные методы Stream API.

Терминальные методы:

+ findFirst - вернет элемент, соответствующий условию, который стоит первым (возвращает Optional)
+ findAny - вернет любой элемент, соответствующий условию (возвращает Optional)
+ forEach - применяет функцию к каждому объекту стрима, порядок при параллельном выполнении не гарантируется
+ collect - представление результатов в виде коллекций и других структур данных
+ count - посчитает и выведет, сколько элементов соответствуют условию (возвращает количество элементов в стриме)
+ anyMatch - возвращает true, если условие выполняется хотя бы для одного элемента
+ noneMatch - возвращает true, если условие не выполняется ни для одного элемента
+ allMatch - возвращает true, если условие выполняется для всех элементов
+ min - возвращает минимальный элемент, в качестве условия использует компаратор
+ max - возвращает максимальный элемент, в качестве условия использует компаратор
+ forEachOrdered - применяет функцию к каждому объекту стрима, сохранение порядка элементов гарантирует
+ toArray - возвращает массив значений стрима
+ reduce - позволяет выполнять агрегатные функции над всей коллекцией и возвращать один результат

Методы findFirst, findAny, anyMatch это short-circuiting методы, то есть обход стримов организуется таким образом, чтобы
найти подходящий элемент максимально быстро, а не обходить весь изначальный стрим.

[К оглавлению &#8593;](#Оглавление)

## 14 Что такое ленивая загрузка?

Лямбда обладает свойством отложенного выполнения.

[К оглавлению &#8593;](#Оглавление)

## 15 Что делает метод filter?

filter (принимает объект Predicate<Task>) отфильтровывает записи, возвращает только записи, соответствующие условию
Допустим, мы получили из коллекции Stream или поток элементов. Каждый элемент передается в метод filter(). Если метод
возвращает true, то элемент передается дальше.

[К оглавлению &#8593;](#Оглавление)

## 16 Что делает метод map.

map преобразует каждый элемент стрима. Map ограничена, потому что каждый объект может быть отображен только одним
объектом.

[К оглавлению &#8593;](#Оглавление)

## 17 Что делает метод flatMap?

flatMap преобразует каждый элемент потока в поток других объектов. Таким образом, каждый объект будет преобразован в
ноль, один или несколько других объектов, поддерживаемых потоком. Содержание этих потоков будет затем помещают в
возвращаемом потоке flatMap операции.

[К оглавлению &#8593;](#Оглавление)

## 18 Что делает метод collect?

collect - представление результатов в виде коллекций и других структур данных

Например:
`.collect(Collectors.toList());`

[К оглавлению &#8593;](#Оглавление)

## 19 Что делает метод reduce?

reduce - позволяет выполнять агрегатные функции над всей коллекцией и возвращать один результат. Это упрощение. В
большинстве случаев используется для получения суммы. `.reduce(0L, Long::sum);`

[К оглавлению &#8593;](#Оглавление)

## 20 Что делает метод findFirst?

findFirst - метод возвращает первый элемент по порядку из Stream-a в виде обертки Optional.

[К оглавлению &#8593;](#Оглавление)

## 21 Возможно ли прервать выполнение потока по аналогии с break?

Нет, но можно использовать takeWhile.

Stream.takeWhile - этот метод позволяет получать поток данных до тех пор, пока условие истина.

`List.of(1, 2, 3, 4).stream()
.takeWhile(v -> v < 3)
.map(v -> "Результат: " + v)
.forEach(System.out::println);`

[К оглавлению &#8593;](#Оглавление)

## 22 Возможно ли пропустить элемент потока по аналогии с continue?

Можно использовать Stream.dropWhile - этот метод позволяет получать поток данных после того, как условие стало ложным.

`List.of(1, 2, 3, 4).stream()
.dropWhile(v -> v < 3)
.map(v -> "Результат: " + v)
.forEach(System.out::println);`

[К оглавлению &#8593;](#Оглавление)

## 23 Что такое Optional?

Optional - это обертка для значений, которые могут содержать null.

[К оглавлению &#8593;](#Оглавление)

## 24 Перечислите методы Optional?

- Чтобы обернуть _null_, используем метод `Optional.empty()`  
  Например: `Optional<User> rsl = Optional.empty();`
- Чтобы обернуть _not-null_ значение, используем `Optional.of(...)`  
  Например: `Optional<User> rsl = Optional.of(user);`
- Чтобы проверить, что объект не null, используем метод `.isPresent()`  
  Например: `if (opt.isPresent()) {}`
- Чтобы получить значение этого объекта, используем метод `opt.get()`

[К оглавлению &#8593;](#Оглавление)

## 25 Расскажите про фабричные методы List.of, Set.of, Map.of?

Фабричные методы в интерфейсах List, Set и Map, позволяют нам создавать неизменяемые экземпляры.  
Метод of возвращает коллекцию, которую можно прочитать, но нельзя изменять или добавлять элементы.

+ List

Создание списка выглядит так:  
```java List<Integer> nums = List.of(1,2,3,4,5); ```  
Метод of() в интерфейсе List перегружен и принимает от одного до десяти элементов. Если хотим создать коллекцию с более
чем десятью элементами, тогда будет использоваться перегруженный метод с varargs  
```java static <E> List<E> of(E... elements) ```  
Сделано это с целью оптимизации, так как при каждом вызове метода c varargs будет создаваться новый массив

+ Set

```java Set<String> questions = Set.of("What?", "Where?", "When?"); ```  
Set также имеет перегруженные методы, но в отличие от List, если передать дубликат в метод of(), то получим исключение  
```java Set<String> questions = Set.of("What?", "What?"); // IllegalArgumentException: duplicate element: What? ```

+ Map

```java Map<String, String> params = Map.of("Name:", "John", "Surname:", "Snow", "Status:", "Unmarried"); ```  
Последовательности идут парами key, value. Всего таких пар может быть 10, в отличие от List и Set. Если в
последовательности будут повторения ключей, получим исключение  
```java Map.of("уникально", "наверняка", "уникально", "но это не точно"); // IllegalArgumentException: duplicate key: уникально ```

Таким образом:

- Вышеупомянутые коллекции нельзя изменить (при попытке получим UnsupportedOperationException);
- В метод of() нельзя передать null (получим NullPointerException);
- Метод of() не создает привычные ArrayList, HashSet или HashMap.

[К оглавлению &#8593;](#Оглавление)

## 26 Для чего используется ключевое слово var?

var - это ключевое слово, которое упрощает создание переменных. Оно:

+ позволяет рационализировать исходный код, избавляя от необходимости излишне указывать тип переменной, когда он может
  быть автоматически выведен из ее инициализатора
+ упростить объявления переменных в тех случаях, когда их типы трудно различить или нельзя обозначить.

[К оглавлению &#8593;](#Оглавление)

## 27 В каких случаях можно использовать var?

var может использоваться только в сочетании с данными.  
Например: `var first = 1;`
Нельзя использовать var без самого значения, потому что JDK нужно знать тип переменной, а тип можно извлечь только из
значения.

Где нельзя использовать var:

1. Поля класса.
2. Параметры метода.
3. Переменные без значения.

[К оглавлению &#8593;](#Оглавление)