# Контрольные вопросы - Коллекции

1. [Что такое "коллекция"](#Что-такое-коллекция)
2. [Перечислите основные методы из интерфейса java.util.Collection.](#Перечислите-основные-методы-из-интерфейса)
3. [Назовите преимущества использования коллекций.](#Назовите-преимущества-использования-коллекций)
4. [Какие данные могут хранить коллекции?](#Какие-данные-могут-хранить-коллекции)
5. [Какие есть типы коллекций? Как они характеризуются?](#Какие-есть-типы-коллекций-Как-они-характеризуются)
6. [Назовите основные реализации List, Set, Map.](#Назовите-основные-реализации-List-Set-Map)
7. [В чём отличие ArrayList от LinkedList?](#В-чём-отличие-ArrayList-от-LinkedList)
8. [В чём отличие HashSet от TreeSet?](В-чём-отличие-HashSet-от-TreeSet)
9. [В чём отличие Set от Map?](В-чём-отличие-Set-от-Map)
10. [Как задается порядок следования объектов в коллекции, как отсортировать коллекцию?](Как-задается-порядок-следования-объектов-в-коллекции,-как-отсортировать-коллекцию)
11. [Чем отличается Comparable от Comparator?](Чем-отличается-Comparable-от-Comparator)
12. [Что такое сортировка по принципу Natural Order?](Что-такое-сортировка-по-принципу-Natural-Order)
13. [Что такое equals и hashcode?](Что-такое-equals-и-hashcode)
14. [Какие есть способы перебора всех элементов List?](Какие-есть-способы-перебора-всех-элементов-List)
15. [Как реализован цикл foreach?](Как-реализован-цикл-foreach)
16. [В чем разница между Iterator и Iterable?](В-чем-разница-между-Iterator-и-Iterable)
17. [Как происходит удаление элементов из ArrayList?](Как-происходит-удаление-элементов-из-ArrayList)
18. [Как происходит удаление элементов из LinkedList?](Как-происходит-удаление-элементов-из-LinkedList)

## Что такое "коллекция"
  
Коллекция - это класс, основная цель которого - хранить набор однородных элементов. В коллекции Java хранятся только ссылки/указатели и ничего
более. Инструменты для работы с такими структурами в Java содержатся в Java Collections Framework.
Фреймворк состоит из интерфейсов, их реализаций и утилитарных классов для работы со списками: 
сортировки, поиска, преобразования.  

## Перечислите основные методы из интерфейса java.util.Collection.  

**Методы для добавления элементов:**
+ boolean add(E e)  
Вводит заданный объект в вызывающую коллекцию. Возвращает логическое значение true, если заданный объект успешно введен в коллекцию, а
если заданный объект уже присутствует в коллекции, которая не допускает дублирование объектов, то возвращается логическое значение false.


+ boolean addAll(Collection<? extends E> c)  
Вводит все элементы заданной коллекции _**с**_ в вызывающую коллекцию. Возвращает логическое значение true, если коллекция изменена
(т.е. все элементы введены), а иначе - логическое значение false

**Чтение элементов из коллекции:**

+ Iterator<E> iterator()  
Возвращает объект Iterator, который позволяет проходить по элементам коллекции.

**Удаление элементов:**

+ boolean remove(Object o)  
Удаляет один экземпляр заданного объекта из вызывающей коллекции. Возвращает логическое значение true, если элемент удален, а иначе - логическое
значение false


+ boolean removeAll(Collection<?> c)  
Удаляет все элементы заданной коллекции _**с**_ из вызывающей коллекции. Возвращает логическое значение true, если в конечном итоге коллекция
изменяется (т.е. элементы из нее удалены), а иначе - логическое значение false.


**Вспомогательные методы:**

+ int size()  
Возвращает количество элементов, содержащихся в коллекции.
  

+ boolean isEmpty()  
Возвращает логическое значение true, если вызывающая коллекция пуста, а иначе - логическое значение false. 


+ boolean contains(Object o)
Возвращает логическое значение true, если заданный объект является элементом вызывающей коллекции, а иначе - логическое значение false.


+ boolean containsAll(Collection<?> с)  
  Возвращает логическое значение true, если вызывающая коллекция содержит все элементы заданной коллекции _**с**_, а иначе - логическое
  значение false


+ void clear()  
  Удаляет все элементы из вызывающей коллекции. После применения этого метода коллекция будет пустой. 


+ Object[] toArray()  
Возвращает массив, содержащий все элементы вызывающей коллекции. Элементы массива являются копиями элементов коллекции

  
## Назовите преимущества использования коллекций.

+ отсутствует необходимость следить за размерами коллекции
+ возможность добавлять, удалять и сортировать элементы
+ обеспечивается высокая производительности, так как реализация основных коллекций (динамических массивов, связных списков, деревьев и хеш-таблиц) 
отличается высокой эффективностью
+ обеспечивается единообразное функционирование коллекций с высокой степенью взаимодействия

## Какие данные могут хранить коллекции?

Коллекции могут хранить любые ссылочные типы данных

## Какие есть типы коллекций? Как они характеризуются?

+ **Set** - это неупорядоченное множество уникальных элементов (нет дубликатов)
+ **List** - упорядоченный список, в котором у каждого элемента есть индекс. Дубликаты значений допускаются.
+ **Queue** - очередь. В таком списке элементы можно добавлять только в хвост, а удалять — только из начала. Так реализуется концепция 
FIFO (first in, first out) — «первым пришёл — первым ушёл». А ещё есть LIFO (last in, first out), то есть «последним пришёл — первым ушёл».
+ **Deque** может выступать и как очередь, и как стек. Это значит, что элементы можно добавлять как в её начало, 
так и в конец. То же относится к удалению.
+ **Map** - (не наследуется от интерфейса Collection, но входит в состав фреймворка Collections) состоит из пар «ключ-значение». Ключи уникальны,
а значения могут повторяться. Порядок элементов не гарантирован. Map позволяет искать объекты (значения) по ключу.

## 5. Назовите основные реализации List, Set, Map.

+ **List**: ArrayList, LinkedList
+ **Set**: HashSet, LinkedHashSat, TreeSet
+ **Map**: HashMap, LinkedHashMap, TreeMap

## 6. В чём отличие ArrayList от LinkedList?

Основное отличие - это организация вставки и удаления элементов.  
 

ArrayList - реализация List интерфейса на основе динамически изменяемого массива, поэтому при вставке элемента в середину, приходится сначала
сдвигать на один все элементы после него, а уже затем в освободившееся место вставлять новый элемент. Зато в нем быстро реализованы взятие и 
изменение элемента. ArrayList - в большинстве случаев лучшая возможная реализация List интерфейса по потреблению памяти и производительности. 
В крайне редких случаях, когда требуются частые вставки в начало или середину списка с очень малым количеством перемещений по списку, LinkedList
будет выигрывать в производительности.
  
LinkedList - реализация List интерфейса на основе двухстороннего связанного списка, то есть когда каждый элемент, указывает на предыдущий и
следующий элемент. Как правило, требует больше памяти и хуже по производительности, чем ArrayList. Имеет смысл использовать в случаях,
когда часто требуется вставка/удаление в середину списка с минимальными перемещениями по списку.

Таким образом, если добавлять и удалять элементы с произвольными индексами в списке нужно чаще, чем итерироваться по нему, то лучше использовать
LinkedList. В остальных случаях — ArrayList.

## В чём отличие HashSet от TreeSet?

HashSet реализован на основе хеш-таблицы, а TreeSet — на основе бинарного дерева.

+ **HashSet** хранит данные в произвольном порядке (хранит свои значения как ключи HashMap).
+ **TreeSet** хранит данные в отсортированном виде (бинарное дерево).

HashSet гораздо быстрее, чем TreeSet (константное время против логарифмического для большинства операций, таких как add, remove, contains), 
но TreeSet гарантирует упорядоченность объектов. Оба не синхронизированы.

## В чём отличие Set от Map?
## Как задается порядок следования объектов в коллекции, как отсортировать коллекцию?
## Чем отличается Comparable от Comparator?
## Что такое сортировка по принципу Natural Order?
## Что такое equals и hashcode?
## Какие есть способы перебора всех элементов List?
## Как реализован цикл foreach?
## В чем разница между Iterator и Iterable?
##  Как происходит удаление элементов из ArrayList?
## Как происходит удаление элементов из LinkedList?