# Контрольные вопросы - Коллекции

1. [Что такое "коллекция"](#Что-такое-коллекция)
2. [Перечислите основные методы из интерфейса java.util.Collection.](#Перечислите-основные-методы-из-интерфейса)
3. [Назовите преимущества использования коллекций.](#Назовите-преимущества-использования-коллекций)
4. [Какие данные могут хранить коллекции?](#Какие-данные-могут-хранить-коллекции)
5. [Какие есть типы коллекций? Как они характеризуются?](#Какие-есть-типы-коллекций-Как-они-характеризуются)
6. [Назовите основные реализации List, Set, Map.](#Назовите-основные-реализации-List-Set-Map)
7. [В чём отличие ArrayList от LinkedList?](#В-чём-отличие-ArrayList-от-LinkedList)
8. [В чём отличие HashSet от TreeSet?](В-чём-отличие-HashSet-от-TreeSet)
9. [В чём отличие Set от Map?](В-чём-отличие-Set-от-Map)
10. [Как задается порядок следования объектов в коллекции, как отсортировать коллекцию?](Как-задается-порядок-следования-объектов-в-коллекции,-как-отсортировать-коллекцию)
11. [Чем отличается Comparable от Comparator?](Чем-отличается-Comparable-от-Comparator)
12. [Что такое сортировка по принципу Natural Order?](Что-такое-сортировка-по-принципу-Natural-Order)
13. [Что такое equals и hashcode?](Что-такое-equals-и-hashcode)
14. [Какие есть способы перебора всех элементов List?](Какие-есть-способы-перебора-всех-элементов-List)
15. [Как реализован цикл foreach?](Как-реализован-цикл-foreach)
16. [В чем разница между Iterator и Iterable?](В-чем-разница-между-Iterator-и-Iterable)
17. [Как происходит удаление элементов из ArrayList?](Как-происходит-удаление-элементов-из-ArrayList)
18. [Как происходит удаление элементов из LinkedList?](Как-происходит-удаление-элементов-из-LinkedList)

## Что такое "коллекция"
  
Коллекция - это класс, основная цель которого - хранить набор однородных элементов. В коллекции Java хранятся только ссылки/указатели и ничего
более. Инструменты для работы с такими структурами в Java содержатся в Java Collections Framework.
Фреймворк состоит из интерфейсов, их реализаций и утилитарных классов для работы со списками: 
сортировки, поиска, преобразования.  

## Перечислите основные методы из интерфейса java.util.Collection.  

**Методы для добавления элементов:**
+ boolean add(E e)  
Вводит заданный объект в вызывающую коллекцию. Возвращает логическое значение true, если заданный объект успешно введен в коллекцию, а
если заданный объект уже присутствует в коллекции, которая не допускает дублирование объектов, то возвращается логическое значение false.


+ boolean addAll(Collection<? extends E> c)  
Вводит все элементы заданной коллекции _**с**_ в вызывающую коллекцию. Возвращает логическое значение true, если коллекция изменена
(т.е. все элементы введены), а иначе - логическое значение false

**Чтение элементов из коллекции:**

+ Iterator<E> iterator()  
Возвращает объект Iterator, который позволяет проходить по элементам коллекции.

**Удаление элементов:**

+ boolean remove(Object o)  
Удаляет один экземпляр заданного объекта из вызывающей коллекции. Возвращает логическое значение true, если элемент удален, а иначе - логическое
значение false


+ boolean removeAll(Collection<?> c)  
Удаляет все элементы заданной коллекции _**с**_ из вызывающей коллекции. Возвращает логическое значение true, если в конечном итоге коллекция
изменяется (т.е. элементы из нее удалены), а иначе - логическое значение false.


**Вспомогательные методы:**

+ int size()  
Возвращает количество элементов, содержащихся в коллекции.
  

+ boolean isEmpty()  
Возвращает логическое значение true, если вызывающая коллекция пуста, а иначе - логическое значение false. 


+ boolean contains(Object o)
Возвращает логическое значение true, если заданный объект является элементом вызывающей коллекции, а иначе - логическое значение false.


+ boolean containsAll(Collection<?> с)  
  Возвращает логическое значение true, если вызывающая коллекция содержит все элементы заданной коллекции _**с**_, а иначе - логическое
  значение false


+ void clear()  
  Удаляет все элементы из вызывающей коллекции. После применения этого метода коллекция будет пустой. 


+ Object[] toArray()  
Возвращает массив, содержащий все элементы вызывающей коллекции. Элементы массива являются копиями элементов коллекции

  
## Назовите преимущества использования коллекций.

+ отсутствует необходимость следить за размерами коллекции
+ возможность добавлять, удалять и сортировать элементы
+ обеспечивается высокая производительности, так как реализация основных коллекций (динамических массивов, связных списков, деревьев и хеш-таблиц) 
отличается высокой эффективностью
+ обеспечивается единообразное функционирование коллекций с высокой степенью взаимодействия

## Какие данные могут хранить коллекции?

Коллекции могут хранить любые ссылочные типы данных

## Какие есть типы коллекций? Как они характеризуются?

+ **Set** - это неупорядоченное множество уникальных элементов (нет дубликатов)
+ **List** - упорядоченный список, в котором у каждого элемента есть индекс. Дубликаты значений допускаются.
+ **Queue** - очередь. В таком списке элементы можно добавлять только в хвост, а удалять — только из начала. Так реализуется концепция 
FIFO (first in, first out) — «первым пришёл — первым ушёл». А ещё есть LIFO (last in, first out), то есть «последним пришёл — первым ушёл».
+ **Deque** может выступать и как очередь, и как стек. Это значит, что элементы можно добавлять как в её начало, 
так и в конец. То же относится к удалению.
+ **Map** - (не наследуется от интерфейса Collection, но входит в состав фреймворка Collections) состоит из пар «ключ-значение». Ключи уникальны,
а значения могут повторяться. Порядок элементов не гарантирован. Map позволяет искать объекты (значения) по ключу.

## Назовите основные реализации List, Set, Map.

+ **List**: ArrayList, LinkedList
+ **Set**: HashSet, LinkedHashSat, TreeSet
+ **Map**: HashMap, LinkedHashMap, TreeMap

## В чём отличие ArrayList от LinkedList?

Основное отличие - это организация вставки и удаления элементов.  

ArrayList - реализация List интерфейса на основе динамически изменяемого массива, поэтому при вставке элемента в середину, приходится сначала
сдвигать на один все элементы после него, а уже затем в освободившееся место вставлять новый элемент. Зато в нем быстро реализованы взятие и 
изменение элемента. ArrayList - в большинстве случаев лучшая возможная реализация List интерфейса по потреблению памяти и производительности. 
В крайне редких случаях, когда требуются частые вставки в начало или середину списка с очень малым количеством перемещений по списку, LinkedList
будет выигрывать в производительности.
  
LinkedList - реализация List интерфейса на основе двухстороннего связанного списка, то есть когда каждый элемент, указывает на предыдущий и
следующий элемент. Как правило, требует больше памяти и хуже по производительности, чем ArrayList. Имеет смысл использовать в случаях,
когда часто требуется вставка/удаление в середину списка с минимальными перемещениями по списку.

Таким образом, если добавлять и удалять элементы с произвольными индексами в списке нужно чаще, чем итерироваться по нему, то лучше использовать
LinkedList. В остальных случаях — ArrayList.

## В чём отличие HashSet от TreeSet?

HashSet реализован на основе хеш-таблицы, а TreeSet — на основе бинарного дерева.

+ **HashSet** хранит данные в произвольном порядке (хранит свои значения как ключи HashMap).
+ **TreeSet** хранит данные в отсортированном виде (бинарное дерево).

HashSet гораздо быстрее, чем TreeSet (константное время против логарифмического для большинства операций, таких как add, remove, contains), 
но TreeSet гарантирует упорядоченность объектов. Оба не синхронизированы.

## В чём отличие Set от Map?

**Set** – это множество – куча ненумерованных объектов. Главная особенность Set – в нем только уникальные объекты, т.е. они все разныe.
**Map** – это множество пар. То же множество, но не одиноких элементов, а пар: **ключ-значение**. Единственное ограничение: первый объект в паре, 
называемый ключом, должен быть _уникальным_. В Map не может содержаться две пары с одинаковыми ключами.

## Как задается порядок следования объектов в коллекции, как отсортировать коллекцию?

Интерфейс Comparator описывает два метода сравнения:
+ int compare(Object obj1, object obj2) — возвращает отрицательное число, если obj1 в каком-то смысле меньше obj2; нуль, если они 
считаются равными; положительное число, если obj1 больше obj2.

+ boolean equals(Object obj) — сравнивает данный объект с объектом obj, возвращая true, если объекты совпадают в каком-либо смысле, 
заданном этим методом.

Для каждой коллекции можно реализовать эти два метода, задав конкретный способ сравнения элементов, и определить объект класса SortedMap
вторым конструктором. Элементы коллекции будут автоматически отсортированы в заданном порядке.

## Чем отличается Comparable от Comparator?

В Java все коллекции, поддерживающие автоматическую сортировку, используют методы сравнения для того, чтобы правильно рассортировать 
элементы. Чтобы рассортировать элементы, класс должен реализовать интерфейсы Comparator или Comparable. Именно поэтому классы-обертки
как Integer, Double и String реализуют интерфейс Comparable.
Интерфейс Comparable помогает сохранять естественную сортировку, тогда как Comparator позволяет сортировать элементы по разным особым 
шаблонам. Экземпляр компаратора обычно передается конструктору коллекции, если коллекция это поддерживает. Следует отметить, что интерфейс 
Comparable может быть реализован именно элементами коллекции или ключами Map, а Comparator реализуется отдельным объектом (это удобно, так
как можно заготовить несколько реализаций для разных правил сортировок, не меняя при этом код элементов коллекции/ключей Map).

Таким образом, через интерфейс _java.util.Comparable_ мы можем задать только один порядок сортировки, а чтобы сделать другой порядок, в 
Java есть интерфейс, который не привязан к модели данных. Это интерфейс _java.util.Comparator_.

## Что такое сортировка по принципу Natural Order?

Естественная сортировка.   
Java знает, что строки чаще всего сортируют по алфавиту, а числа — по возрастанию их значения. Поэтому, если вызвать на списке чисел или
строк метод sort(), так они будут отсортированы.

## Что такое equals и hashcode?

Методы, необходимые для определения равенства объектов.
+ hashcode возвращает число, являющееся уникальным идентификатором объекта.
Это алгоритм, который позволяет множество значений объектов сузить до какого-то натурального количества.
+ equals сравнивает объекты по значению их полей.

## Какие есть способы перебора всех элементов List?

Есть 4 способа:

+ Цикл с итератором
+ Цикл for
+ Расширенный цикл for
+ Цикл while

## Как реализован цикл foreach?

Цикл foreach реализован на основе Iterator.

## В чем разница между Iterator и Iterable?

Все коллекции в Java реализуют интерфейс Iterable.  
Интерфейс Iterable представляет собой структуру данных, которая может быть повторена.   
Интерфейс Iterable предоставляет метод, который создает итератор.

Мы можем перебирать элементы внутри коллекции, используя расширенный цикл for, также называемый циклом for-each. Однако в 
таком операторе можно использовать только объекты, реализующие интерфейс Iterable. Т
акже можно перебирать элементы, используя оператор while в сочетании с итератором.

##  Как происходит удаление элементов из ArrayList?`

Перекидывание элемента в конец массива путем смещения всех последующих элементов, а затем уменьшение поля size на 1.

## Как происходит удаление элементов из LinkedList?`

Замена ссылок prev и next у соседних элементов.
