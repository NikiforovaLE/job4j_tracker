# Контрольные вопросы - ООП

1. [Что такое ООП?](#Что-такое-ООП)
2. [Базовые концепции ООП](#Базовые-концепции-ООП)
3. [Укажите, из каких элементов состоит класс](#Укажите-из-каких-элементов-состоит-класс)
4. [Что такое конструктор?](#Что-такое-конструктор)
5. [Можно ли наследовать конструктор?](#Можно-ли-наследовать-конструктор)
6. [Что такое перегрузка конструктора?](#Что-такое-перегрузка-конструктора)
7. [Что такое статический метод?](#Что-такое-статический-метод)
8. [Что такое не статический метод?](#Что-такое-не-статический-метод)
9. [Для чего используется ключевое слово this?](#Для-чего-используется-ключевое-слово-this)
10. [Какой класс является базовым родительным классом для всех классов?](#Какой-класс-является-базовым-родительным-классом-для-всех-классов)
11. [Что такое наследование? Приведите примеры из реальной жизни.](#Что-такое-наследование?-Приведите-примеры-из-реальной-жизни)
12. [Опишите процесс создания нового объекта.](#Опишите-процесс-создания-нового-объекта)
13. [Как вызвать метод из родительского класса?](#Как-вызвать-метод-из-родительского-класса)
14. [Что такое переопределение метода?](#Что-такое-переопределение-метода)
15. [Можно ли переопределить статический метод?](#Можно-ли-переопределить-статический-метод)
16. [Что такое виртуальная функция и используются ли они в Java?](#Что-такое-виртуальная-функция-и-используются-ли-они-в-Java)
17. [Что такое перегрузка метода?](#Что-такое-перегрузка-метода)
18. [Можно ли изменить тип возвращаемых данных при перегрузке метода?](#Можно-ли-изменить-тип-возвращаемых-данных-при-перегрузке-метода)
19. [Что такое множественное наследование? Как его можно реализовать в Java.](#Что-такое-множественное-наследование?-Как-его-можно-реализовать-в-Java)
20. [Что такое полиморфизм? Приведите примеры из реальной жизни.](#Что-такое-полиморфизм?-Приведите-примеры-из-реальной-жизни)
21. [Что такое инкапсуляция?](#Что-такое-инкапсуляция)
22. [Как реализована инкапсуляция в Java?](#Как-реализована-инкапсуляция-в-Java)
23. [Можно ли применить модификаторы доступа к конструкторам?](#Можно-ли-применить-модификаторы-доступа-к-конструкторам)
24. [Что такое интерфейс?](#Что-такое-интерфейс)
25. [Какие типы исключительных ситуаций бывают?](#Какие-типы-исключительных-ситуаций-бывают)
26. [Назовите основные методы класса Object?](#Назовите-основные-методы-класса-Object)
27. [Что такое шаблоны проектирования?](#Что-такое-шаблоны-проектирования)
28. [Объясните шаблон декоратор.](#Объясните-шаблон-декоратор)
29. [Объясните шаблон стратегия](#Объясните-шаблон-стратегия)

## Что такое ООП?

ООП объектно-ориентированное программирование - это методика программирования, которая помогает организовывать сложные программы, 
применяя принципы наследования, инкапсуляции и полиморфизма.  
Такой подход предполагает разработку приложений с помощью классов и объектов. Таким образом, программа представляется в виде совокупности
объектов, каждый из которых является экземпляром определенного класса. В свою очередь объект внутри использует структурное программирование.

## Базовые концепции ООП

+ **`Абстракция`** - выделение значимой информации и исключение из рассмотрения незначимой.  
С точки зрения программирования, это правильное разделение программы на объекты.


+ **`Инкапсуляция`** - механизм, связывающий код и данные, которыми он манипулирует, защищая оба компонента от внешнего вмешательства 
и злоупотреблений. Проще говоря, инкапсуляция в Java - это "сокрытие реализации".  
Основу инкапсуляции в Java составляет класс, назначение которого состоит в инкапсуляции сложной структуры программы, поэтому 
существуют механизмы сокрытия сложной структуры реализации в самом классе. 
Каждый метод или переменная в классе могут быть помечены как открытые или закрытые.  
*Открытый* интерфейс класса представляет всё, что должны или могут знать внешние пользователи класса.  
*Закрытые* методы и данные могут быть доступны только для кода, который является членом данного класса, а значит, любой другой код, 
не являющийся членом данного класса, не может получать доступ к закрытому методу или переменной. Закрытые члены класса доступны другим
частям программы только через открытые методы класса, и благодаря этому исключается возможность выполнения неправомерных действий.


+ **`Наследование`** - процесс, в результате которого один объект получает свойства другого.  
Наследование обеспечивает принцип иерархической классификации.  
Наследуемый (родительский) класс - ***суперкласс***.  
Наследующий (дочерний) класс - ***подкласс***.  
Подкласс - это специализированная версия суперкласса. Он наследует все члены, определённые в суперклассе, добавляя к ним собственные, 
особые элементы.  
Для каждого создаваемого подкласса можно указать **только 1 суперкласс**. В Java не поддерживается наследование нескольких суперклассов
в одном подклассе. Можно создать иерархию наследования, где один подкласс становится суперклассом другого подкласса.  
Чтобы наследовать класс, достаточно ввести определение одного класса в другом, используя ключевое слово ***extends***.


+ **`Полиморфизм`** - это принцип ООП, которые позволяет использовать один и тот же интерфейс для общего класса действий.  
Способы реализации полиморфизма:  
-перегрузка методов;  
-переопределение методов

## Укажите, из каких элементов состоит класс

Класс состоит из *полей* и *методов*.

Данные, или переменные, определённые в классе, называются *переменными экземпляра*.
Вместе с переменными экземпляра методы, определённые в классе, называются *членами класса*.

## Что такое конструктор?

**Конструктор** - это специальный метод, который вызывается при создании нового объекта перед окончанием выполнения операции *new*. 
Таким образом, операция `new`вызывает конструктор класса.


Имя конструктора совпадает с именем класса (с соблюдением регистра), при этом синтаксически конструктор похож на метод без 
возвращаемого значения. Конструктор автоматически инициализирует внутреннее состояние объекта непосредственно во время его создания. 

Конструктор нужен для того, чтобы код, создающий экземпляр, с самого начала содержал полностью инициализированный, пригодный к 
употреблению объект. Если конструктор не определён явно, то в Java для класса создаётся *конструктор по умолчанию* (неявный), который
инициализирует все переменные экземпляра устанавливаемыми по умолчанию значениями.  
Конструктор с параметрами (явный) - **параметризованный конструктор**. Как только в классе будет определён явный конструктор, 
конструктор по умолчанию *больше не используется*. Поэтому, если мы пишем конструктор, который принимает аргументы и нам потребуется
вариант конструктора без аргументов, то нужно создать его самостоятельно. Компилятор создаст конструктор без аргументов, если мы сами не
создали ни одного конструктора.

## Можно ли наследовать конструктор?

Нет.   
В Java подкласс наследует все члены (поля, методы, вложенные классы) из суперкласса, но конструкторы не являются членами, поэтому 
они не наследуются, однако конструктор суперкласса может быть вызван из подкласса.

## Что такое перегрузка конструктора?

Перегрузка конструкторов означает определение в одном и том же классе нескольких конструкторов, которые отличаются типом и/или количеством 
параметров.   
Если два конструктора принимают по одному значению типа int, то класс не скомпилируется. Имеет значение *типы* параметров и *порядок* их 
следования. То есть могут быть два конструктора с параметрами идентичных типов, но эти параметры должны размещаться 

## Что такое статический метод?

Статический метод привязан к классу, а не к объекту. Такие методы вызываются независимо от любого объекта этого класса.

Ограничения статических методов:
+ они могут непосредственно вызывать только другие статические методы
+ им непосредственно доступны только статические переменные
+ они не могут делать ссылки типа *this* или *super*

## Что такое не статический метод?

Не статический метод - это метод, для работы которого необходим объект. Не статический метод принадлежит объекту класса и может быть 
вызван с помощью ссылки на данный объект.  
Вызов такого метода осуществляется через операцию-точку.

## Для чего используется ключевое слово this?

Ключевое слово this служит ссылкой на объект, для которого был вызван метод.   
Когда имя локальной переменной совпадает с именем переменной экземпляра, локальная переменная *скрывает* переменную экземпляра. 
Ключевое слово this позволяет ссылаться непосредственно на объект.

## Какой класс является базовым родительным классом для всех классов?

Класс Objeсt служит суперклассом для всех остальных классов. Ссылочная переменная из класса Objeсt может ссылаться на объект любого
другого класса.

## Что такое наследование? Приведите примеры из реальной жизни.

**Наследование**` - процесс, в результате которого один объект получает свойства другого, а именно: когда один объект перенимает все 
публичные поля и методы другого объекта.   
Наследование обеспечивает принцип иерархической классификации.

Примеры наследования из реальной жизни:  
Животные -> Млекопитающие -> Собачьи -> Домашние -> Охотничьи -> Ретривер  
Автомобили -> Легковые -> Внедорожники -> Ford

## Опишите процесс создания нового объекта.

Создание объекта происходит в два этапа:
1. Сначала следует объявить переменную типа класса. Она не определяет объект, а является переменной, которая может *ссылаться* на объект. 
2. Затем нужно получить конкретную физическую копию объекта и присвоить её этой переменной. Это делается с помощью операции new. Эта 
операция динамически, то есть во время выполнения, резервирует память для объекта и возвращает ссылку на него. Эта ссылка представляет 
собой адрес объекта в памяти. Затем эта ссылка сохраняется в переменной.

В общем виде создание объекта выглядит следующим образом:  
тип_класса переменная_класса = new имя_класса();

## Как вызвать метод из родительского класса?

Если метод суперкласса переопределён в подклассе и требуется получить доступ к варианту переопределенного метода из суперкласса, 
необходимо использовать ключевое слово *super*.  
Когда переопределенный метод вызывается из своего подкласса, он всегда ссылается на свой вариант, определенный в подклассе, а вариант 
метода, определенный в суперклассе, будет скрыт. 

## Что такое переопределение метода?

Переопределение метода - это создание иного варианта метода суперкласса в подклассе.  
Переопределение методов выполняется только в том случае, если имена и сигнатуры типов обоих методов одинаковы. Тогда говорят, что метод
из подкласса переопределяет метод из суперкласса.

## Можно ли переопределить статический метод?

Статический метод **нельзя** переопределить: он принадлежит классу и не наследуется, но в то же время его можно перегрузить.  
Метод, обозначенный ключевым словом static, принадлежит не объекту класса, а именно классу, и он загружается при загрузке самого класса.

## Что такое виртуальная функция и используются ли они в Java?

Виртуальные функции используются в языках С++ или С#. Переопределенные методы в Java подобны виртуальным функциям в этих языках.

## Что такое перегрузка метода?

Перегрузка методов - это процесс определения в одном и том же классе двух или более методов под одним именем, но с разным объявлением их
параметров. В этом случае методы называют *перегружаемыми*.  
Перегружаемые методы должны отличаться по типу и/или количеству их параметров. Возвращаемые типы перегружаемых методов могут отличаться,
но самого возвращаемого типа явно недостаточно, чтобы отличить два разных варианта метода. Когда в исполняющей среде Java встречается 
вызов перегружаемого метода, в ней просто выполняется тот его вариант, параметры которого соответствуют аргументам, указанным в вызове.

## Можно ли изменить тип возвращаемых данных при перегрузке метода?

Да, можно, но самого возвращаемого типа явно недостаточно, иначе JVM не поймет, какой метод ей нужно вызвать. Поэтому необходимо, чтобы
отличались тип и/или количество параметров метода.

## Что такое множественное наследование? Как его можно реализовать в Java.

Множественное наследование - это наследование класса от нескольких суперклассов одновременно. В Java не поддерживается множественное 
наследование. Можно создать иерархию наследования, где один подкласс становится суперклассом другого подкласса.  
В Java множественное наследование можно в какой-то, хотя и ограниченной, степени реализовать с помощью интерфейсов.

## Что такое полиморфизм? Приведите примеры из реальной жизни.

**Полиморфизм** - это принцип ООП, которые позволяет использовать один и тот же интерфейс для общего класса действий. Полиморфизм также
описывают выражением: "Один интерфейс - множество реализаций".  
Полиморфизм - это возможность применения одноименных методов с одинаковыми или различными наборами параметров в одном классе или в 
группе классов, связанных отношением наследования.

Способы реализации полиморфизма:
- перегрузка методов;
- переопределение методов

Примеры: собачье обоняние. Когда собака почувствует запах кошки, она залает и погонится за ней, когда собака почувствует запах еды, 
она побежит к миске. В обоих случаях действует одно и то же чувство обоняния. Отличие лишь в том, что именно издает запах, т.е. в типе
данных, воздействующих на нос собаки.

## Что такое инкапсуляция?

**`Инкапсуляция`** - механизм, связывающий код и данные, которыми он манипулирует, защищая оба компонента от внешнего вмешательства и 
злоупотреблений. Проще говоря, инкапсуляция в Java - это "сокрытие реализации". 

## Как реализована инкапсуляция в Java?

Для реализации инкапсуляции в Java используются:
+ модификаторы доступа - специальные слова, которые определяют доступ к данным
+ специальные методы - геттеры и сеттеры

Например, переменные класса объявляются как private, а для изменения и просмотра значений переменных к методам установки и получения 
(сеттеру и геттеру) предоставляется модификатор доступа public.

## Можно ли применить модификаторы доступа к конструкторам?

Да, можно.

## Что такое интерфейс?

Интерфейс-это абстрактный тип, содержащий набор методов и постоянных переменных. Это конструкция языка Java, в рамках которой принято 
описывать абстрактные публичные (abstract public) методы и статические константы (final static). С помощью интерфейса можно указать, что
именно должен выполнять класс, реализующий его, но не как это выполнить. Способ реализации выбирает сам класс. Интерфейсы не способны 
сохранять данные состояния.

Интерфейсы задают описание, как должен работать объект, и не содержат реализации, но в версии JDK 8 появилась возможность определять 
реализацию по умолчанию метода, объявленного в интерфейсе. Если конкретная реализация такого метода отсутствует, то используется его 
реализация по умолчанию в интерфейсе.

Чтобы реализовать интерфейс в классе, необходимо использовать ключевое слова *implements*.

В интерфейсе разрешено использовать:
+ поля - константы `public static final`;
+ абстрактные методы - задают то, как должен работать наш объект, но не определяют, как именно;
+ статические методы - можем добавлять с Java 8 как обычные `static` методы;
+ методы по умолчанию.

У интерфейсов **нет конструкторов**.

Особенности интерфейсов:
+ нельзя создавать экземпляры интерфейсов напрямую
+ интерфейс может быть пустым
+ нельзя использовать слово *final* в определении интерфейса, так как это приведет к ошибке компилятора
+ все объявления интерфейса должны иметь модификатор доступа public или по умолчанию. Модификатор *abstract* будет добавлен компилятором
автоматически 
+ метод интерфейса не может быть закрытым, защищенным или окончательным 
+ переменные интерфейса являются общедоступными, статическими и окончательными по определению. 

## Какие типы исключительных ситуаций бывают?

***Исключение*** - это ненормальная ситуация, возникающая во время выполнения последовательности кода. Иными словами, исключение - это 
ошибка, возникающая во время выполнения. Когда возникает такая ситуация, в вызвавшем ошибку методе генерируется объект, который 
представляет исключение. Этот метод может обработать исключение самостоятельно или же пропустить его. Так или иначе, в определенный момент
исключение *перехватывается* и *обрабатывается*. 

![Exceptions](http://job4j.ru/api/images/imageTaskPreview?imageId=459)

Все типы исключений являются подклассами, производными от встроенного класса **Throwable**. Это означает, что класс Throwable находится 
на вершине иерархии классов исключений. Сразу же за классом Throwable ниже по иерархии следуют два подкласса, разделяющие все исключения
на две ветви. 

Одну ветвь возглавляет класс **Exception**. Он служит для исключительных условий, которые должна перехватывать прикладная программа.
Именно от этого класса нужно наследовать свои подклассы при создании собственных типов исключений. 

Данный класс определяет ошибки, связанные с работой самой программы, которые можно разделить на два типа: **проверяемые** (checked) и
**непроверяемые** (unchecked) исключения (RuntimeException). Исключения типа RuntimeException автоматически определяются для создаваемых
разработчиком прикладных программ и охватывают такие ошибки, как деление на нуль и ошибочная индексация массивов.

Другая ветвь возглавляется классом **Error**, определяющим исключения, появление которых не предполагается при нормальном выполнении 
программы. Исключения типа Error используются в исполняющей системе Java для обозначения ошибок, происходящих в самой исполняющей среде.
Примером такой ошибки может служить переполнение стека, использование одинаковых библиотек с разными версиями. То есть класс Error 
определяет ошибки, связанные с работой виртуальной машины.

Исключения могут генерироваться автоматически исполняющей системой Java или вручную в прикладном коде. Исключения, генерируемые 
исполняющей системой Java, имеют отношение к фундаментальным ошибкам, нарушающим правила языка Java или ограничения, налагаемые 
исполняющей системой Java. А исключения, генерируемые вручную, обычно служат для уведомления вызывающего кода о некоторых ошибках в 
вызываемом методе.

Управление обработкой исключений в Java осуществляется с помощью пяти ключевых слов: **try, catch, throw, throws и finally**.   
Операторы программы, которые требуется отслеживать на предмет исключений, размещаются в блоке `try`. Если исключение возникает в блоке try,
оно генерируется. Прикладной код может перехватить исключение, используя блок `catch`, а затем обработать его некоторым рациональным 
способом. Системные исключения автоматически генерируются исполняющей системой Java. Для генерирования исключения вручную служит ключевое
слово **throw**. Любое исключение, генерируемое в теле метода, должно быть обозначено в его объявлении ключевым словом **throws**. А любой код,
который необходимо выполнить по завершении блока try, размещается в блоке `finally`.

```java
try {
// блок кода, в котором отслеживаются ошибки
catch (тип_исключения_l ехОЬ) {
// обработчик исключений тип_исключения_l
catch (тип_исключения_2 ехОЬ) {
// обработчик исключений тип_исключения_2
}
/ / ...
finally
// блок кода, который должен быть непременно
// выполнен по завершении блока try
```

Когда исполняющая система Java обнаруживает исключительную ситуацию, она создает новый объект исключения, а затем генерирует исключение.
Это прерывает выполнение текущего класса, ведь как только исключение сгенерировано, оно должно быть перехвачено обработчиком исключений
и немедленно обработано. Когда обработчик исключений отсутствует, исключение перехватывается стандартным обработчиком, предоставляемым
исполняющей системой Java. Любое исключение, не перехваченное прикладной программой, в конечном итоге будет перехвачено и обработано этим
стандартным обработчиком. Стандартный обработчик выводит символьную строку с описанием исключения и результат трассировки стека, начиная с
момента возникновения исключения, а затем прерывает выполнение программы.

Стандартный обработчик исключений, предоставляемый исполняющей системой Java, удобен для отладки, но, как правило, обрабатывать исключения
приходится вручную. Это дает два существенных преимущества. Во-первых, появляется возможность исправить ошибку. Во-вторых, предотвращается
автоматическое прерывание выполнения программы. Чтобы организовать обработку ошибок, возникающих во время выполнения, достаточно разместить
контролируемый код в блоке оператора `try`. Сразу же за блоком оператора `try` должен следовать блок оператора `catch`, где указывается
тип перехватываемого исключения. Как только возникнет исключение, управление сразу же передается из блока оператора `try` в блок оператора
`catch`. По завершении блока оператора catch управление передается в строку кода, следующую после всего блока операторов try/catch.

Здесь тип_исключения обозначает тип возникающего исключения.

Исключения, как было сказано, можно генерировать и непосредственно в прикладной программе, используя оператор throw. Его общая форма 
выглядит следующим образом:  
`throw генерируемый_экземпляр;`
Здесь генерируемый_экземпляр должен быть объектом класса Throwable или производного от него подкласса. Примитивные типы вроде int или char,
а также классы, кроме Throwable, например String или Obj ect, нельзя использовать для генерирования исключений. Получить объект класса
Throwable можно двумя способами, указав соответствующий параметр в операторе *саtсh* или создав этот объект с помощью операции new.
Поток исполнения программы останавливается сразу же после оператора throw, а все последующие операторы не выполняются. В этом случае 
ближайший объемлющий блок оператора *try* проверяется на наличие в нем оператора *саtch* с совпадающим типом исключения. Если совпадение
обнаружено, управление передается этому оператору. В противном случае проверяется следующий внешний блок оператора *try* и т.д. Если же не
удастся найти оператор catch, совпадающий с типом исключения, то стандартный обработчик исключений прерывает выполнение программы и 
выводит результат трассировки стека.

Если метод способен вызвать исключение, которое он сам не обрабатывает, то он должен задать свое поведение таким образом, чтобы вызывающий
его код мог обезопасить себя от такого исключения. С этой целью в объявление метода вводится оператор **throws**, где перечисляются типы
исключений, которые метод может генерировать. Это обязательно для всех исключений, кроме тех, которые относятся к классам Error и 
RuntimeException или любым их подклассам. Все остальные исключения, которые может сгенерировать метод, должны быть объявлены в операторе
throws. Если этого не сделать, то во время компиляции возникнет ошибка.

Общая форма объявления метода, которая включает оператор throws:

```java
тип имя_метода(список_параметров) throws список_исключений
{
    // тело метода
}
```
Здесь _список_исключений_ обозначает разделяемый запятыми список исключений, которые метод может сгенерировать.

## Назовите основные методы класса Object?

*Object clone()* - создаёт новый объект, не отличающийся от клонируемого  
*boolean equals(Object object)* - определяет, равен ли один объект другому  
*Class<?> getClass()* - получает класс объекта во время выполнения  
*int hashCode()* - возвращает хеш-код, связанный с вызывающим объектом  
*void notify()* - возобновляет исполнение потока, ожидающего вызывающего объекта  
*void notifyAll()* - возобновляет исполнение всех потоков, ожидающих вызывающий объект  
*String toString()* - возвращает символьную строку, описывающую объект  
*void wait()* - ожидает другого потока исполнения  

## Что такое шаблоны проектирования?

Шаблон проектирование (паттерн) означает схему решения часто возникающей задачи проектирования. Паттерны лишь описывают подход, но не 
описывают шаги реализации.

Основные характеристики шаблонов:
+ имя - все шаблоны имеют уникальное имя, служащее для их идентификации;
+ назначение - назначение данного шаблона; 
+ задача - задача, которую шаблон позволяет решить; 
+ способ решения - способ, предлагаемый в шаблоне для решения задачи в том контексте, где этот шаблон был найден;
+ участники - сущности, принимающие участие в решении задачи; 
+ следствия - последствия от использования шаблона как результат действий, выполняемых в шаблоне; 
+ реализация - возможный вариант реализации шаблона.

Выделяют следующие категории шаблонов проектирования:
+ **Порождающие** - абстрагируют процесс создание экземпляра. Они позволяют сделать систему не зависимой от способа создания, композиции
и представления объектов. Например, "Как создать объект, который нельзя изменить"? "Как создать класс, который будет создавать новые 
объекты других классов?".
+ **Структурные** - решают проблемы эффективного построения связей между объектами. Они отвечают за иерархию классов и интерфейсов. 
Например, "как заставить объекты с несовместимыми интерфейсами работа вместе"?
+ **Поведенческие** - решают проблемы эффективного взаимодействия между объектами. Например, "как сделать так, чтобы объекты одного класса
следили за изменениями в других классах и реагировали на них"?

## Объясните шаблон декоратор.

Паттерн декоратор относится к структурным шаблонам проектирования.  С его помощью объект динамически наделяется новыми возможностями.

## Объясните шаблон стратегия

Этот шаблон относится к поведенческим шаблонам, при котором происходит объединение нескольких возможных алгоритмов поведения объекта 
в единый класс. Каждый алгоритм взаимозаменяем и выбирается прямо во время выполнения программы.